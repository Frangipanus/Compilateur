# dune build main.exe
# OCAMLPARAM: unset
# Shared cache: disabled
# Shared cache location: /home/paul/.cache/dune/db
# Workspace root:
# /home/paul/Documents/Travail/ENS/L3/Info/Compilation/Compilateur
# Auto-detected concurrency: 16
# Dune context:
#  { name = "default"
#  ; kind = "default"
#  ; profile = Dev
#  ; merlin = true
#  ; fdo_target_exe = None
#  ; build_dir = In_build_dir "default"
#  ; instrument_with = []
#  }
$ /usr/bin/ocamlc.opt -config > /tmp/dune_2198c6_output
$ (cd _build/default && /usr/bin/ocamldep.opt -modules -impl algow.ml) > _build/default/.main.eobjs/algow.impl.d
$ (cd _build/default && /usr/bin/ocamlc.opt -g -bin-annot -I .main.eobjs/byte -no-alias-deps -opaque -o .main.eobjs/byte/algow.cmo -c -impl algow.ml)
> File "algow.ml", lines 218-221, characters 18-30:
> 218 | ..................match head t with
> 219 |   | Tint | Tbool | Tstring | Tunit -> Vset.empty
> 220 |   | Tarrow(tl, ft) -> List.fold_left (fun acc t' -> Vset.union acc (fvars t')) Vset.empty (ft.typ::tl)
> 221 |   | Tvar v -> Vset.singleton v
> Warning 8 [partial-match]: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Tlist _|Tmaybe _)
> File "algow.ml", lines 399-401, characters 12-143:
> 399 | ............let Tlist(t2) = head tbe2.typ.typ in
> 400 |             unify_types t1 t2;
> 401 |             { bexpr = EBinop(op, tbe1, tbe2); loc = bexpr.loc; typ = { typ = Tlist(t1); effect = add_effect tbe1.typ.effect tbe2.typ.effect } }
> Warning 8 [partial-match]: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Tint|Tbool|Tstring|Tunit|Tarrow (_, _)|Tmaybe _|Tvar _)
> File "algow.ml", lines 398-401, characters 12-143:
> 398 | ............let Tlist(t1) = head tbe1.typ.typ in
> 399 |             let Tlist(t2) = head tbe2.typ.typ in
> 400 |             unify_types t1 t2;
> 401 |             { bexpr = EBinop(op, tbe1, tbe2); loc = bexpr.loc; typ = { typ = Tlist(t1); effect = add_effect tbe1.typ.effect tbe2.typ.effect } }
> Warning 8 [partial-match]: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Tint|Tbool|Tstring|Tunit|Tarrow (_, _)|Tmaybe _|Tvar _)
> File "algow.ml", lines 478-487, characters 10-13:
> 478 | ..........begin match args with
> 479 |           | [be1; be2] ->
> 480 |               let tbe1 = w_bexpr env be1 fun_name return_type in
> 481 |               let tbe2 = w_bexpr env be2 fun_name return_type in
> 482 |               try
> 483 |                 unify_types tbe1.typ.typ (Tmaybe tbe2.typ.typ);
> 484 |                 { bexpr = Default(tbe1, tbe2); typ = { typ = tbe2.typ.typ; effect = add_effect tbe1.typ.effect tbe2.typ.effect }; loc = bexpr.loc }
> 485 |               with UnificationFailure(_,_) -> raise (TypeError "Arguments incompatibles")
> 486 |           | _ -> raise (TypeError "Mauvais nombre d'arguments pour default")
> 487 |           end
> Warning 8 [partial-match]: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> {loc=(_, _); _ }::{loc=(_, _); _ }::{loc=(_, _); _ }::_
> File "algow.ml", lines 490-498, characters 10-13:
> 490 | ..........begin match args with
> 491 |           | [be] ->
> 492 |               let tbe = w_bexpr env be fun_name return_type in
> 493 |               try
> 494 |                 unify_types tbe.typ.typ (Tlist (Tvar(V.create ())));
> 495 |                 { bexpr = Head(tbe); typ = { typ = Tmaybe tbe.typ.typ; effect = tbe.typ.effect }; loc = bexpr.loc }
> 496 |               with UnificationFailure(_,_) -> raise (TypeError "head prend une liste en argument")
> 497 |           | _ -> raise (TypeError "Mauvais nombre d'arguments pour head")
> 498 |           end
> Warning 8 [partial-match]: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> {loc=(_, _); _ }::{loc=(_, _); _ }::_
> File "algow.ml", lines 501-509, characters 10-13:
> 501 | ..........begin match args with
> 502 |           | [be] ->
> 503 |               let tbe = w_bexpr env be fun_name return_type in
> 504 |               try
> 505 |                 unify_types tbe.typ.typ (Tlist (Tvar(V.create ())));
> 506 |                 { bexpr = Tail(tbe); typ = tbe.typ; loc = bexpr.loc }
> 507 |               with UnificationFailure(_,_) -> raise (TypeError "tail prend une liste en argument")
> 508 |           | _ -> raise (TypeError "Mauvais nombre d'arguments pour tail")
> 509 |           end
> Warning 8 [partial-match]: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> {loc=(_, _); _ }::{loc=(_, _); _ }::_
> File "algow.ml", line 378, characters 12-14:
> 378 |         let t2 = head tbe2.typ.typ in
>                   ^^
> Warning 26 [unused-var]: unused variable t2.
> File "algow.ml", line 419, characters 14-16:
> 419 |           let t3 = head tbe3.typ.typ in
>                     ^^
> Warning 26 [unused-var]: unused variable t3.
$ (cd _build/default && /usr/bin/ocamlopt.opt -g -I .main.eobjs/byte -I .main.eobjs/native -intf-suffix .ml -no-alias-deps -opaque -o .main.eobjs/native/main.cmx -c -impl main.ml)
> File "main.ml", line 61, characters 8-10:
> 61 |     let p2 = Algow.w p in 
>              ^^
> Warning 26 [unused-var]: unused variable p2.
$ (cd _build/default && /usr/bin/ocamlopt.opt -g -I .main.eobjs/byte -I .main.eobjs/native -intf-suffix .ml -no-alias-deps -opaque -o .main.eobjs/native/algow.cmx -c -impl algow.ml)
> File "algow.ml", lines 218-221, characters 18-30:
> 218 | ..................match head t with
> 219 |   | Tint | Tbool | Tstring | Tunit -> Vset.empty
> 220 |   | Tarrow(tl, ft) -> List.fold_left (fun acc t' -> Vset.union acc (fvars t')) Vset.empty (ft.typ::tl)
> 221 |   | Tvar v -> Vset.singleton v
> Warning 8 [partial-match]: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Tlist _|Tmaybe _)
> File "algow.ml", lines 399-401, characters 12-143:
> 399 | ............let Tlist(t2) = head tbe2.typ.typ in
> 400 |             unify_types t1 t2;
> 401 |             { bexpr = EBinop(op, tbe1, tbe2); loc = bexpr.loc; typ = { typ = Tlist(t1); effect = add_effect tbe1.typ.effect tbe2.typ.effect } }
> Warning 8 [partial-match]: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Tint|Tbool|Tstring|Tunit|Tarrow (_, _)|Tmaybe _|Tvar _)
> File "algow.ml", lines 398-401, characters 12-143:
> 398 | ............let Tlist(t1) = head tbe1.typ.typ in
> 399 |             let Tlist(t2) = head tbe2.typ.typ in
> 400 |             unify_types t1 t2;
> 401 |             { bexpr = EBinop(op, tbe1, tbe2); loc = bexpr.loc; typ = { typ = Tlist(t1); effect = add_effect tbe1.typ.effect tbe2.typ.effect } }
> Warning 8 [partial-match]: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Tint|Tbool|Tstring|Tunit|Tarrow (_, _)|Tmaybe _|Tvar _)
> File "algow.ml", lines 478-487, characters 10-13:
> 478 | ..........begin match args with
> 479 |           | [be1; be2] ->
> 480 |               let tbe1 = w_bexpr env be1 fun_name return_type in
> 481 |               let tbe2 = w_bexpr env be2 fun_name return_type in
> 482 |               try
> 483 |                 unify_types tbe1.typ.typ (Tmaybe tbe2.typ.typ);
> 484 |                 { bexpr = Default(tbe1, tbe2); typ = { typ = tbe2.typ.typ; effect = add_effect tbe1.typ.effect tbe2.typ.effect }; loc = bexpr.loc }
> 485 |               with UnificationFailure(_,_) -> raise (TypeError "Arguments incompatibles")
> 486 |           | _ -> raise (TypeError "Mauvais nombre d'arguments pour default")
> 487 |           end
> Warning 8 [partial-match]: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> {loc=(_, _); _ }::{loc=(_, _); _ }::{loc=(_, _); _ }::_
> File "algow.ml", lines 490-498, characters 10-13:
> 490 | ..........begin match args with
> 491 |           | [be] ->
> 492 |               let tbe = w_bexpr env be fun_name return_type in
> 493 |               try
> 494 |                 unify_types tbe.typ.typ (Tlist (Tvar(V.create ())));
> 495 |                 { bexpr = Head(tbe); typ = { typ = Tmaybe tbe.typ.typ; effect = tbe.typ.effect }; loc = bexpr.loc }
> 496 |               with UnificationFailure(_,_) -> raise (TypeError "head prend une liste en argument")
> 497 |           | _ -> raise (TypeError "Mauvais nombre d'arguments pour head")
> 498 |           end
> Warning 8 [partial-match]: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> {loc=(_, _); _ }::{loc=(_, _); _ }::_
> File "algow.ml", lines 501-509, characters 10-13:
> 501 | ..........begin match args with
> 502 |           | [be] ->
> 503 |               let tbe = w_bexpr env be fun_name return_type in
> 504 |               try
> 505 |                 unify_types tbe.typ.typ (Tlist (Tvar(V.create ())));
> 506 |                 { bexpr = Tail(tbe); typ = tbe.typ; loc = bexpr.loc }
> 507 |               with UnificationFailure(_,_) -> raise (TypeError "tail prend une liste en argument")
> 508 |           | _ -> raise (TypeError "Mauvais nombre d'arguments pour tail")
> 509 |           end
> Warning 8 [partial-match]: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> {loc=(_, _); _ }::{loc=(_, _); _ }::_
> File "algow.ml", line 378, characters 12-14:
> 378 |         let t2 = head tbe2.typ.typ in
>                   ^^
> Warning 26 [unused-var]: unused variable t2.
> File "algow.ml", line 419, characters 14-16:
> 419 |           let t3 = head tbe3.typ.typ in
>                     ^^
> Warning 26 [unused-var]: unused variable t3.
$ (cd _build/default && /usr/bin/ocamlopt.opt -g -o main.exe .main.eobjs/native/ast.cmx .main.eobjs/native/algow.cmx .main.eobjs/native/parser.cmx .main.eobjs/native/lexer.cmx .main.eobjs/native/main.cmx)
# Promoting "_build/default/main.exe" to "main.exe"
